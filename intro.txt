JAVA - HIGH level language
COMPILER - BINARY format me CONVERT krta hai

Primitive data types - includes byte, short, int, long, float, double, boolean and char
Non-primitive data types - such as String, Arrays and Classes

boolean, byte in 64bit machine - 1 byte
char in 64bit machine - 2 byte
int, float - in 64bit machine = 4 byte
long, double - in 64 bit machine = 8byte

The byte data type can store whole numbers from -128 to 127
The short data type can store whole numbers from -32768 to 32767
The int data type can store whole numbers from -2147483648 to 2147483647
long - very large : Note that you should end the value with an "L" 
    ->long myNum = 15000000000L;

The float and double data types can store fractional numbers. Note that you should end the value with an "f" for floats and "d" for doubles

Java Type Casting -> 1. Widening Casting  , 2. Narrowing Casting 

byte -> short -> int -> float -> long -> double (each j can casted into i>j)

Coversion happens when : 1. type compatible eg: int -> str not possible 2. destination type > source type (in size)

----------------------------------------- TYPE PROMOTION -------------------------------------

1. Java automatically converts BYTE,CHAR,SHORT to INT while eval an EXPRESSION.
2. If one expression if LONG, FLOAT, DOUBLE then whole exp is converted into LONG,FLOAT,DOUBLE respectively.

---------------------------------------------------------------------------------------------------------

OPERATORS : 
    BITWISE X-OR        : ^
    BITWISE LEFT SHIFT  : <<
    BITWISE RIGHT SHIFT : >>

BITWISE AND/OR : &  / | 
LOGICAL AND/OR : && / ||

STRING : .length() :: STRING[] : .length
1st is a string , 2nd is a array of strings

method overloading ->  multiple methods can have the same name with different parameters/ body

new (keyword) -> isko use krtey hai to define space in memory for non-primitive data type ⭐⭐⭐

1 word input : .next() :: 1 line input : .nextLine() 

⭐ Strings are immutable ⭐ -> To its rescue comes the String builder class

BIT MASKING -> PROCESS OF DOING BIT MANIPULATION throught OPERATIONS like - GET, SET, CLEAR, UPDATE
BIT MASK -> NUMBER used for the above process


------------------------------    RECURSION   ----------------------------------

-> when recursive funcs are called again n again -> they get pushed on a STACK
-> for eg: func(int i) -> for each recursive call -> `i` is created in the memory , which doesn't happen in iteration
-> if there is not base condition then the problem STACK OVERFLOW will occur due to MEMORY getting filled
-> When we reach the base case then it gets popped off the stack
-> The last thing left on top of the stack will be returned by the function call

----------------------------------------------------------------------------------------






